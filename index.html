<!DOCTYPE html>
<html lang="es">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Knight's Tour Infinito</title>
  <style>
    body { font-family: Arial; background: #111; color: #fff; margin: 0; padding: 2rem; }
    button { margin-top: 1rem; padding: 0.5rem 1rem; font-size: 1rem; }
    #log { white-space: pre-wrap; max-height: 50vh; overflow-y: auto; background: #222; padding: 1rem; }
  </style>
</head>
<body>
  <h1>Knight's Tour sin Límite</h1>
  <button onclick="startSearch()">Iniciar Búsqueda</button>
  <button onclick="stopSearch()">Detener</button>
  <button onclick="exportSolutions()">Exportar JSON</button>
  <div id="log"></div>

  <script>
    const N = 5; // Tamaño del tablero
    let running = false;
    let db;
    let solutionsSet = new Set(); // Para evitar duplicados en memoria

    const directions = [
      [2, 1], [1, 2], [-1, 2], [-2, 1],
      [-2, -1], [-1, -2], [1, -2], [2, -1]
    ];

    function createBoard() {
      return Array.from({ length: N }, () => Array(N).fill(-1));
    }

    function isSafe(x, y, board) {
      return x >= 0 && x < N && y >= 0 && y < N && board[y][x] === -1;
    }

    // Crea nombre único para la solución según su inicio, segundo y último paso
    function getName(path) {
      const start = path[0];
      const second = path[1];
      const end = path[path.length - 1];
      return `${start[0]}${start[1]}_${second[0]}${second[1]}_${end[0]}${end[1]}`;
    }

    function openDB() {
      return new Promise((resolve, reject) => {
        const request = indexedDB.open("KnightTourDB", 1);
        request.onupgradeneeded = function (e) {
          const db = e.target.result;
          if (!db.objectStoreNames.contains("solutions")) {
            db.createObjectStore("solutions", { keyPath: "id" });
          }
        };
        request.onsuccess = () => resolve(request.result);
        request.onerror = () => reject("Error abriendo IndexedDB");
      });
    }

    async function saveSolution(path) {
      const baseName = getName(path);
      // Si ya existe en memoria, no la guardamos
      if (solutionsSet.has(baseName)) return false;
      solutionsSet.add(baseName);

      const id = baseName + "_" + Date.now();
      const tx = db.transaction("solutions", "readwrite");
      const store = tx.objectStore("solutions");
      return new Promise((resolve, reject) => {
        const addReq = store.add({ id, path });
        addReq.onsuccess = () => resolve(true);
        addReq.onerror = () => resolve(false);
      });
    }

    async function knightTour(x, y, movei, board, path) {
      if (!running) return;
      board[y][x] = movei;
      path.push([x, y]);

      if (movei === N * N - 1) {
        const saved = await saveSolution([...path]);
        if (saved) log(`Guardada: ${getName(path)}`);
        board[y][x] = -1;
        path.pop();
        return;
      }

      for (const [dx, dy] of directions) {
        const nx = x + dx, ny = y + dy;
        if (isSafe(nx, ny, board)) {
          // Respetar tiempo para no bloquear UI
          await new Promise(r => setTimeout(r, 0));
          await knightTour(nx, ny, movei + 1, board, path);
          if (!running) break;
        }
      }

      board[y][x] = -1;
      path.pop();
    }

    async function startSearch() {
      if (running) return;
      running = true;
      db = await openDB();
      solutionsSet.clear();
      log("Iniciando búsqueda infinita...");
      for (let x = 0; x < N && running; x++) {
        for (let y = 0; y < N && running; y++) {
          await knightTour(x, y, 0, createBoard(), []);
        }
      }
      if (running) log("Búsqueda finalizada.");
      running = false;
    }

    function stopSearch() {
      running = false;
      log("Búsqueda detenida.");
    }

    function log(text) {
      const logEl = document.getElementById("log");
      logEl.textContent += text + "\n";
      logEl.scrollTop = logEl.scrollHeight;
    }

    async function exportSolutions() {
      if (!db) {
        log("Primero inicia la búsqueda para abrir la base de datos.");
        return;
      }
      const tx = db.transaction("solutions", "readonly");
      const store = tx.objectStore("solutions");
      const all = store.getAll();
      all.onsuccess = () => {
        if (!all.result.length) {
          log("No hay soluciones para exportar.");
          return;
        }
        const blob = new Blob([JSON.stringify(all.result, null, 2)], { type: "application/json" });
        const a = document.createElement("a");
        a.href = URL.createObjectURL(blob);
        a.download = "knight_solutions.json";
        a.click();
        log("Exportación iniciada.");
      };
    }
  </script>
</body>
</html>
